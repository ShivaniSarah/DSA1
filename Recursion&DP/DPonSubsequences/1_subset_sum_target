# https://www.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1

# Subset Sum Problem

N = 6
arr[] = {3, 34, 4, 12, 5, 2}
sum = 9
Output: 1 
Explanation: Here there exists a subset with
sum = 9, 4+3+2 = 9.


# Recursion:

def f(i,s,arr,N):
            
            if s-arr[i]==0:
                return 1
            if i>=N or s<0:
                return 0
            
            if s-arr[i]>0:
                p = f(i+1,s-arr[i],arr,N)
                n = f(i+1,s,arr,N)
                return max(p,n)
            return f(i+1,s,arr,N)
        
        return f(0,sum,arr,N)
            

# DP I

    def f(i,s,arr,N,dp):
            if s==0:
                return 1
            if s<0:
                return 0
            if i>=N:
                return 0
            
            if dp[i][s]!=-1:
              return dp[i][s]

            p = f(i+1,s-arr[i],arr,N,dp) 
            n = f(i+1,s,arr,N,dp)
            dp[i][s]=max(p,n)
            
            return dp[i][s]
            
        
        dp= [[-1 for i in range(sum+1)] for j in range(N+1)]
        
        return f(0,sum,arr,N,dp) 

# DP II:

class Solution:
    def isSubsetSum (self, N, arr, sum):

        dp = [[False for _ in range(sum + 1)] for _ in range(N + 1)]
        
        # If sum is 0, then it's always possible to form the sum with an empty subset
        for i in range(N + 1):
            dp[i][0] = True
        
        # Fill the dp array
        for i in range(1, N + 1):
            for j in range(1, sum + 1):
                if arr[i - 1] <= j:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        
        # The answer is whether we can form the sum with all N elements
        return dp[N][sum]

# DP II:

class Solution:
    
    #Function to return max value that can be put in knapsack of capacity W.
    def knapSack(self,W, wt, val, n):
        
        
        # Create a 2D DP array
        dp = [[0 for _ in range(W + 1)] for _ in range(n+1)]
            
        # Build the DP table in a bottom-up manner
        for i in range(1,n+1):
            for w in range(W + 1):
                if wt[i - 1] <= w:  # If the item can be included
                    dp[i][w] = max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w])
                else:  # If the item cannot be included
                    dp[i][w] = dp[i - 1][w]
    
        # The last cell of the DP table will hold the result
        return dp[n][W]
