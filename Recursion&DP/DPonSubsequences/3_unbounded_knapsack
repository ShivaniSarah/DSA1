https://www.geeksforgeeks.org/problems/knapsack-with-duplicate-items4201/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=knapsack-with-duplicate-items

Given a set of N items, each with a weight and a value, represented by the array w and val respectively.
Also, a knapsack with weight limit W.
The task is to fill the knapsack in such a way that we can get the maximum profit. 
Return the maximum profit.
Note: Each item can be taken any number of times.

Example 1:
Input: 
N = 2
W = 3
val = {1, 1}
wt = {2, 1}
Output: 
3
Explanation: 
1.Pick the 2nd element thrice.
2.Total profit = 1 + 1 + 1 = 3. Also the total weight = 1 + 1 + 1  = 3 which is <= 3.

Example 2:
Input: 
N = 4
W = 8
val[] = {6, 1, 7, 7}
wt[] = {1, 3, 4, 5}
Output: 
48
Explanation: 
The optimal choice is to pick the 1st element 8 times.

Expected Time Complexity: O(N*W)
Expected Auxiliary Space: O(W)

DP I:

import sys
class Solution:
    def knapSack(self, N, W, val, wt):
        def f(wt, val,ind, W, dp):        
            if ind == 0:
                return (W // wt[0]) * val[0]
        
            # If the result for this state is already calculated, return it
            if dp[ind][W] != -1:
                return dp[ind][W]
        
            # Calculate the maximum value when the current item is not taken
            notTaken = f(wt, val, ind - 1, W, dp)
        
            # Initialize a variable to store the maximum value when the current item is taken
            taken = -sys.maxsize
            if wt[ind] <= W:
                taken = val[ind] + f(wt, val, ind, W - wt[ind], dp)
        
            # Store the maximum of "notTaken" and "taken" in the DP table
            dp[ind][W] = max(notTaken, taken)
            return dp[ind][W]
        
        dp = [[-1 for _ in range(W + 1)] for _ in range(N)]
        return f(wt, val, N - 1, W, dp)

DP II:

