Find Missing And Repeating

https://www.geeksforgeeks.org/problems/find-missing-and-repeating2512/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=find-missing-and-repeating

Given an unsorted array Arr of size N of positive integers. One number 'A' from set {1, 2,....,N} is missing and 
one number 'B' occurs twice in array. Find these two numbers.

Input:
N = 2
Arr[] = {2, 2}
Output: 2 1
Explanation: Repeating number is 2 and 
smallest positive missing number is 1.

Input:
N = 3
Arr[] = {1, 3, 3}
Output: 3 2
Explanation: Repeating number is 3 and 
smallest positive missing number is 2.

Brute Approach:

class Solution:
    def findTwoElement( self,a, n):
        repeating, missing = -1, -1
        # Find the repeating and missing number:
        for i in range(1, n+1):           # len of array = 10 , range of nos anticipated is 1 to 10
            # Count the occurrences:
            cnt = 0
            for j in range(n):
                if a[j] == i:
                    cnt += 1
    
            if cnt == 2:
                repeating = i
            elif cnt == 0:
                missing = i
    
            if repeating != -1 and missing != -1:
                break
    
        return [repeating, missing]

TC: O(N^2)
SC: O(1)

Better Approach:

class Solution:
    def findTwoElement( self,a, n):
        n = len(a) # size of the array
        hash = [0] * (n + 1) # hash array
    
        #update the hash array:
        for i in range(n):
            hash[a[i]] += 1
    
        #Find the repeating and missing number:
        repeating, missing = -1, -1
        for i in range(1, n + 1):
            if hash[i] == 2:
                repeating = i
            elif hash[i] == 0:
                missing = i
    
            if repeating != -1 and missing != -1:
                break
        return [repeating, missing]

TC: O(2N)
SC: O(N)

# Optimal I Approach

class Solution:
    def findTwoElement( self,a, n):
        n = len(a)  # size of the array

        # Find Sn and S2n:
        SN = (n * (n + 1)) // 2
        S2N = (n * (n + 1) * (2 * n + 1)) // 6
    
        # Calculate S and S2:
        S, S2 = 0, 0
        for i in range(n):
            S += a[i]
            S2 += a[i] * a[i]
        # repeating = Y, missing = X 
        # S-Sn = X-Y:
        val1 = S - SN
    
        # S2-S2n = X^2-Y^2 = (X-Y)(X+Y) = (S-Sn)(X+Y) => X+Y = (S2-S2n)/(S-Sn)
        val2 = S2 - S2N

        # X+Y = val2//val1

        # combining X-Y =val1 and X+Y =val2//val1
        # X= ( val1 + (val2/val1) )/2 
        # Y=  X - val1

        x = (val1 + (val2//val1)) // 2
        y = x - val1
    
        return [x, y]

TC: O(n)
SC: O(1)

# Optimal II Approach:

class Solution:
    def findTwoElement( self,a, n):
        n = len(a) # size of the array

        xr = 0
    
        #Step 1: Find XOR of all elements:
        for i in range(n):
            xr = xr ^ a[i]
            xr = xr ^ (i + 1)
    
        #Step 2: Find the differentiating bit number:
        number = (xr & ~(xr - 1))
    
        #Step 3: Group the numbers:
        zero = 0
        one = 0
        for i in range(n):
            #part of 1 group:
            if ((a[i] & number) != 0):
                one = one ^ a[i]
            #part of 0 group:
            else:
                zero = zero ^ a[i]
    
        for i in range(1, n + 1):
            #part of 1 group:
            if ((i & number) != 0):
                one = one ^ i
            #part of 0 group:
            else:
                zero = zero ^ i
    
        # Last step: Identify the numbers:
        cnt = 0
        for i in range(n):
            if (a[i] == zero):
                cnt += 1
    
        if (cnt == 2):
            return [zero, one]
            
        return [one, zero]

TC: O(n)
SC: O(1)
